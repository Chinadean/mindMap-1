<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>test events</title>
		<!--	共用文件，不要修改	start	-->
		<link href="../css/qunit.css" rel="stylesheet" type="text/css" />
		<script type="text/javascript" src="../js/base.js"></script>
		<script type="text/javascript" src="../js/lib/tools/qunit.js"></script>
		<!--	共用文件，不要修改	end	-->
		<script type="text/javascript">
			kampfer.require('events');
		</script>
	</head>
	<body>
		<!--	共用文件，不要修改	start	-->
		<h1 id="qunit-header">QUnit for events</h1>
		<h2 id="qunit-banner"></h2>
		<div id="qunit-testrunner-toolbar"></div>
		<h2 id="qunit-userAgent"></h2>
		<ol id="qunit-tests"></ol>
		<div id="qunit-fixture">
			test markup, will be hidden
			<div id="parent">
				<div id="child"></div>
			</div>
		</div>
		<!--	共用文件，不要修改	end	-->
		<script type="text/javascript">
			function $(id) {
				return document.getElementById(id);
			}
			
			var p = $('parent'),
				c = $('child'),
				liaowei = {
					name : 'liaowei',
					nickName : 'kampfer',
					sex : 'male',
					age : '25',
					job : 'Engineer'
				};
				
			test('初始状态，没有为任何对象建立缓存', function() {
				var data = kampfer.dataManager._data(c);
				ok(!data.events, 'elemData.events不存在');
			});
			
			test('为DOM绑定click事件', function() {
				var key = kampfer.events.addEvent(c, 'click', kampfer.emptyFn);
				
				ok( key !== undefined, '成功执行addEvent都将返回一个key' );
				
				var events = kampfer.dataManager._data(c, 'events');
				ok( events, 'addEvent生成了events');
				ok( kampfer.type(events) === 'object', 'events是object' );
				ok( events.click, 'addEvent生成了events.click' );
				ok( kampfer.type(events.click) === 'array', 'events.click是数组' );
				ok( events.click.length === 1, 'events.click.length = 1' );
				ok( events.proxy, 'addEvent生成了events.proxy' );
				ok( kampfer.type(events.proxy) === 'object', 'events.proxy是object' );
				ok( kampfer.type(events.proxy.click) === 'function', 
					'第一次为对象绑定click事件，将生成一个proxy函数并通过native方法绑定到对象上，proxy函数被存储到events.proxy对象中');
				
				var handlerObj = events.click[0];
				ok( handlerObj, '用户操作被保存在一个handlerObj对象中，该对象储存在events.click中');
				ok( handlerObj.key === key, 'handlerObj.key正确' );
				ok( handlerObj.handler === kampfer.emptyFn, 'handlerObj.handler正确' );
				ok( handlerObj.scope === undefined, 'handlerObj.scope正常' );
				ok( handlerObj.type === 'click', 'handlerObj.type正常' );
				
				k.events.removeEventByKey(c, 'click', key);
			});
			
			test('为DOM重复绑定事件', function(){
				var emptyFn = function() {};
				
				var key = kampfer.events.addEvent(c, 'click', emptyFn);
				var events = kampfer.dataManager._data(c, 'events');
				var length = events.click.length;
				
				var key2 = kampfer.events.addEvent(c, 'click', emptyFn);
				//events2不必每次都读一遍
				var events2 = kampfer.dataManager._data(c, 'events');
				var length2 = events.click.length;
				
				var handlerObj = events.click[1];
				
				ok( key !== undefined && key2 !== undefined, '每次成功执行addEvent都将返回唯一key' );
				ok( length === 1 && length2 === 2 && events.click[1].key === key2, 'handlerObj被push入events.click数组' );
				ok( events.proxy.click === events2.proxy.click, '重复绑定相同事件不会生成新的proxy函数' );
				
				ok( !events2.focus, 'events.focus不存在' );
				ok( !events2.proxy.focus, 'events3.proxy.focus不存在' );
				var key3 = kampfer.events.addEvent(c, 'focus', function() {});
				//var events3 = kampfer.dataManager._data(c, 'events');
				ok( events2.focus, 'events.focus存在' );
				ok( events2.focus[0].key === key3, 'events.focus[0]存在' );
				ok( events2.proxy.focus, 'events3.proxy.focus存在' );
				
				k.events.removeEventByKey(c, 'click', key);
				k.events.removeEventByKey(c, 'click', key2);
				k.events.removeEventByKey(c, 'focus', key3);
			});
			
			test('触发DOM click事件', function(){
				var handler = function() {
					ok(true, 'click事件被触发');
				};
				
				var key = kampfer.events.addEvent(c, 'click', handler);
				var key2 = kampfer.events.addEvent(c, 'click', handler);
				
				kampfer.events.fireEvent(c, 'click');
				
				ok( key !== key2, '重复绑定相同操作成功');
				
				k.events.removeEventByKey(c, 'click', key);
				k.events.removeEventByKey(c, 'click', key2);
			});
			
			test('检查this与event', function() {
				var handler = function(event) {
					ok(this === c, 'this === c');
					ok(event.type === 'click', 'event.type正确');
					ok(event.target === c, 'event.target正确');
					ok(event.currentTarget === c, 'event.currentTarget正确');
				};
				
				var key = kampfer.events.addEvent(c, 'click', handler);
				kampfer.events.fireEvent(c, 'click');
				
				k.events.removeEventByKey(c, 'click', key);
			});
			
			test('传递自定义数据', function() {
				var handler = function(event) {
					ok( event.owner, '成功传递了自定义数据' );
					ok( event.owner.name === 'liaowei', '自定义数据的键值正确' );
				}
				
				k.events.addEvent(c, 'click', handler);
				k.events.fireEvent(c, 'click', {owner:liaowei});
			});
		</script>
	</body>
</html>